[COLOSSEUM - TO DO LIST] (O = work in progress, X = done)
	_ sounds: turret firing (cannon/laser), projectile hitting (ding!), turret turning (servomotor)
	_ pick apart the collide_all() method for ways to put that code into the objects rather than in the giant, monolithic function.
	_ bonus timer for each level, set by no. of enemies
	O instant cooldown pickup
	_ feedback system (google groups?)
	_ create a subspace-style networked multiplayer mode: duel. first to 5 by 2, rinse, repeat. two players only.
	X show a little music icon and sound volume indicator somewhere to show when music is on/off
	X add an "M for music" thing to the help screen
	_ destructible armor plates of varying effectiveness and mass
			when damaged, they show noticeable changes and look "beat up".
			when dead, they actually fall off, allowing the player to be damaged in that area. The player does not have a lot of life.
	_ futuristic, painted art theme for all environments and units.
	_ player intro/outro sequence
			player starts in a darkish "locker room" with a gate leading out. The gate opens, the room is lit, and the player's engine starts up.
			then the player is given control of the vehicle and must drive out into the arena
			then the gate closes and the first level starts.
			at the end of each level, a kill/cash sheet is displayed with sound effects
			then the player is brought to the in-between-levels menu, with a store for upgrades and so forth.
			when the next level is begun, the player once again starts in the locker room.
	_ gates to spawn enemies
	_ engine sounds -- startup, idle loop (which changes based on motive force or velocity), shut-down
	_ cheat code to allow player to spawn as any enemy
	_ two-player networked co-op, vs, player-vs-enemies, enemies-vs-enemies
	X forces, mass, acceleration, velocity, frictional forces, rotational forces, torque, collision response system based on it
	_ Joystick controls (XBOX 360 and "others") allowing analog control of motive forces, rotational and direct
	_ levels defined as a grid of squares, blocking or non blocking, made up of elongated rectangular walls (which can be rotated arbitrarily (optional))
			but naturally must not cramp the level and make it impossible to get anywhere
	_ homing missiles (player & enemy, tracks nearest enemy) simple greedy pathing
	_ AI pathing (A*) can "malfunction" if the AI is damaged (ie, return sucky paths)
	_ create a predictive aiming system for the AI, based on velocity of AI's avatar, its target, and the muzzle velocity/acceleration of its weapon(s).
	X create a rudimentary AI
	_ "tazer caster" -- weapon with two components, fired in sequence from the main barrel.
			when one of the components hits an enemy, it sticks.
			if both components hit enemies, an electrified wire is enabled and starts to destroy the enemies.
			if any other enemies also touch the tazer wire, they are also damaged.
			if the player touches the tazer wire, [I haven't decided what happens]
	_ field to have a complex agent's maximum rotational force magnitude be a variable itself
			calculated as a function of velocity, specified with a single coefficient.
			application: motorcycles, who have trouble turning at high speeds
	_ "gun buddies" -- automated helper agents, mobile or immobile type
			has own AI, and would automatically seek out and destroy enemies until killed.
			can be purchased like ammunition, and can be configured like the player's tank.
	_ "air strikes" -- level-based superweapons, can be picked up. Only one at a time can be equipped/held in reserve
	_ laser-based weapons which use a "POWER" meter.
	_ "batteries" for storing POWER.
	_ "generators" which determine power regen rate.
	_ RAIL-based weapons
			instantly travels from source to target, and leave behind a trail that animates (really a series of particles laid out in a line)
			has a fake physics system around it, represents a low-mass slug with a very high velocity
	_ EMP weapons
	_ shields (uses power)
			can be reconfigured at any time to emphasize front, back, or to be evenly spread
	_ stealth device (uses power)
	_ UPGRADES: weapon damage (using ammunition, purchasable), max health, speed (tread type), acceleration (engine), armor (plates, bought in sets, destroyable, visible, can fall off), muzzle velocity of all weapons, turret rotation speed
	X machine gun overheat
	_ ammunition class/type/object for association with turrets. Turrets can store multiple types of ammo, and be pointing to an active one. Each ammunition object would keep track of units remaining.
	_ DEPLOYABLE state for complex agents. Either switch the image entirely or have special animated gizmos that animate with a function call.
	_ deploy-gizmos would be some kind of special particle with two states, and an image set for animation frames
			when activated, the gizmo would animate forwards and then freeze.
			when activated again, the gizmo would animate backwards and freeze it its original state.
	_ ammunition loading/reloading animation, and an animation joining the ammo pickup to the ammo display when it gets granted()
	X for TURRETs, allow for an arbitrary number of each type of emitter.
	_ enemy spawner (Carson's idea)
	_ put explosion, smoke, spark and damage scar emitters into projectiles.
			when the projectile hits something, emit everything ("dump its load").
	O sound
	X emitters should have a particle_archetype_index range (min/max) so that they can emit many different particles
	_ explosions can also have short-lived "spark" emitters, and sparks have such trails as mentioned above
	X velocity range for projectile emitters -- ties in to weapon accuracy
	X angular velocity for particles
	X angular velocity range for particle emitters
	_ motivator class for animating "treads" and handling debris and trail emitters, attached to complex agents
	X remove dynamic fields (usually physics-related) from CREATE functions (changed them to "Archetype_.." functions)
	X class archetype libraries
	_ put class archetype initialization into XML files
	X create projectile emitter type
	X weapon accuracy values, implemented with angle variance in the projectile emitter
	X attach various emitters to turret class to be called logically on fire()
	X turret recoil
	X emitter's parent can be a particle (or projectile)
			applications: missiles!
	X alpha values for particles, birth & death
	X tread emitter and manager list
	X damage for player and enemies
	X encapsulate turret logic and make a class for it
	_ create xml format for levels
	_ create a level editor
	X implement a physics engine, using Chris Hecker's PDF's as an example
			linear forces, center of mass, rotational physics, etc.
			application: obviously, to make the game world seem more "real"
	X create gibs for enemies
	X make gibs spawn as particles when enemies die
	_ create scars
	X create "shells" to be ejected from the ejector port of turret object
	_ create blocks for static environments that can be collided with
	_ create example arenas
	X create a few enemies with guns
	_ create visible damage which "sticks" to agents
	X separate main components into files
	