[COLOSSEUM - TO DO LIST] (O = work in progress, X = done)
	_ put class-specific constants into respective TYPE's using "Global" fields - I didn't know that could be done until just now.
			so Types can apparently have "Fields" and "Globals" - basically static fields.
	_ bake_level_bg() and bake_level_fg() functions ..
			.. that each take a LEVEL object as an argument, and return a TImage object containing appropriate procedurally-generated level images fit for drawing.
			cache_level_bg() will need to draw the "sand" texture based on the total size, as well as some "prefab" structures potentially (for gates/doors on outside wall spawn points)
			cache_level_fg() will need to draw the walls, multi-layered things based on the LEVEL objects' pre-cached wall list. Walls that "touch" will need to look like it.
			different base textures and prefabs could be used here to change the "theme" of the level
			levels will also need to create door widgets for the "outside" spawn points
				and also pop-out-of-ground widgets for spawn points that are meant to be for turrets (or "surprise" enemies)
			
	X divider-based level system with dynamic sized pathing grid
	_ make static functions out of the CPU-intensive AI tasks such as find path and see target etc
			these global functions keep track of their own global delay timers, so that if there are a lot of requests, some will get denied.
	_ if a control_brain cannot see its current target, have it request another.
	_ create a GAME object which contains all of the managed object lists.
			GAME would also have an update() and a draw() method.
			this way it will be possible to keep different simultaneous games separate, such as in the case of the menu AI demo and the actual game being separate.
	_ gibs object with a gib image (with many gib frames potentially)
			also containing a list of angles and velocity ranges, to be applied when agent is gibbed
	_ grenade launcher
	_ laser turret needs to have some more emitters
			puff of little smoke to either side (maybe)
			battery/shell casing ejected, possibly with neat glow fade-out effect
	_ rocket turret needs more emitters also (this is potentially a duplicate)
			two rocket shell casing emitters in back, 45 deg angles
			a large-ish muzzle flash, also out the back
			lots of smoke out the back
	_ turret_groups should have logical linkages through the complex_agent parent to an anchor point.
			turret_groups would thus only be attached to pre-set anchor points on the complex_agent
			when any turret_group's turn() function is called, any linked turret groups also get called implicitly.
			the linkage would be at a complex_agent level, and the turret groups themselves would need no knowledge of the link or the anchor point.
			also need a complex_agent method to get the current orientation of all turret_groups associated with a given anchor.
	_ the projectile_launcher:EMITTER should have the code to play the sound associated with its emission
			(and not the turret itself)
	_ same goes for particle emitters; they should have an option to play a sound when they emit.
			this way, explosion emitters could automatically emit the explosion sound associated with it.
	
	[control_brain to-do]	
		_ new field group: behavior_state%, behavior_started_ts%, behavior_time%
			these fields are by the control brain to determine the current behavior, and allow it to finish between updates.
		_ new field: squadmates:TList, a list of COMPLEX_AGENTs
			behaviors can use the squadmates list for swarming and other complex behaviors
		_ encapsulate more behaviors in preparation for scriptable AI.
		X add a random_wander() behavior, for use by any CONTROL_BRAIN which does not have a path to follow.
		X add a friendly_fire() behavior, which checks to see if the line of sight to current target is blocked by a friendly
		_ add a dodge() behavior, which forces the agent to move out of the way of incoming projectiles
		
	_ agent/door collisions not working
	X mouse turret control, mouse-click tank control
	X when returning to locker, put a spotlight on it, and darken the rest of the arena.
	_ animated particles for agent death
	_ scriptable AI.
	_ allow RANGE objects to have mathematical equations to calculate the distribution of returned values
	_ take mini-snapshots of kills, and display them in an album at the end of the level.
			(experimental!)
	_ create a "turret_system" object or group of variables, so that I can talk about the angle and turning velocity of the whole system.
			turrets that are conceptually attached to each other really ought to be modelled that way.
	_ reload-meter
	_ flaming gibs w/ sparks & flaming heaps/wrecks
	_ since sequenced/grouped turrets can be fired together, it only makes sense that they can be "turned" together as well.
			I want to be able to say turn_turret_group( sequence_index% ) and have it turn that whole group.
	_ definitely need a cool animated spawn particle for turrets, as they cannot move.
			thinking something like a metal hatch with teeth and two doors that opens up or something, and then explodes/gibs
	_ animated "spawn" particle for temporary use, when enemies spawn in.
	_ animated particles (for frame-by-frame explosions, it really is necessary.)
	_ Create global POINT objects to represent the gates, and have widgets attached to them.
			when the spawning step begins, open all the gates until all agents are in the arena; then close all the gates.
			when the level has concluded:
				if the player has defeated all the enemies, open the player's gate and allow the player to travel to the spawn point.
				if the player is dead, open all the enemies' gates, and have the enemies travel into a random gate, then delete them behind the scenes. When all enemies have left the arena, close all the gates.
	_ Remove the static Create() functions from the object definitions, and instead write global "factory" functions to auto-cast {Type}.Create:Object calls to the desired types
			(e.g. Create_COMPLEX_AGENT:COMPLEX_AGENT( .. ))
			so that callers do not have to typecast the returned object to the desired type. IT'S ANNOYING.
	_ create a specialized emitter mode for gibs (EMITTER_TYPE_GIBS)
			in this mode, the emitter is disabled until the parent explicitly triggers it.
			On agent death, the emitter is triggered; it then iterates through a list of particles and emits them without changing their positions or velocities (except to add them to the parents').
	X for intro, make the player push a button (like "E") to start the vehicle, and then drive out of the locker.
	X arena background: increase size to 600x600 for locker rooms
	_ OPTIMIZATION: Initial checks using CollideRect() to save computing time
	_ shadows for agents (and possibly other objects)
	_ screen shake -- when an enemy explodes, shake the screen by an amount proportional to the explosive force.
	_ rocket turret -- this turret needs more effect emitters.
			it needs two shell casing emitters in the front, to show the rocket being launched, and in the rear, a large smoke emitter and a large 'muzzle flash'
	O sounds:
		X turret firing (cannon/laser)
		X projectile hitting (ding!)
		_ turret turning (servomotor)
		_ pickups
	X pick apart the collide_all() method for ways to put that code into the objects rather than in the giant, monolithic function.
	_ bonus timer for each level, set by no. of enemies
	X instant cooldown pickup
	_ feedback system (google groups?)
	_ create a subspace-style networked multiplayer mode: duel. first to 5 by 2, rinse, repeat. two players only.
	X show a little music icon and sound volume indicator somewhere to show when music is on/off
	X add an "M for music" thing to the help screen
	_ destructible armor plates of varying effectiveness and mass
			when damaged, they show noticeable changes and look "beat up".
			when dead, they actually fall off, allowing the player to be damaged in that area. The player does not have a lot of life.
	_ futuristic, painted art theme for all environments and units.
	O player intro/outro sequence
			player starts in a darkish "locker room" with a gate leading out. The gate opens, the room is lit, and the player's engine starts up.
			then the player is given control of the vehicle and must drive out into the arena
			then the gate closes and the first level starts.
			at the end of each level, a kill/cash sheet is displayed with sound effects
			then the player is brought to the in-between-levels menu, with a store for upgrades and so forth.
			when the next level is begun, the player once again starts in the locker room.
	X gates to spawn enemies
	X engine sounds -- startup, idle loop (which changes based on motive force or velocity), shut-down
	_ cheat code to allow player to spawn as any enemy
	_ two-player networked co-op, vs, player-vs-enemies, enemies-vs-enemies
	X forces, mass, acceleration, velocity, frictional forces, rotational forces, torque, collision response system based on it
	_ Joystick controls (XBOX 360 and "others") allowing analog control of motive forces, rotational and direct
	X levels defined as a grid of squares, blocking or non blocking, made up of elongated rectangular walls (which can be rotated arbitrarily (optional))
			but naturally must not cramp the level and make it impossible to get anywhere
	_ homing missiles (player & enemy, tracks nearest enemy) simple greedy pathing
	X AI pathing (A*)
	_ allow pathing to "malfunction" if the AI is damaged (ie, return sucky paths)
	_ create a predictive aiming system for the AI, based on velocity of AI's avatar, its target, and the muzzle velocity/acceleration of its weapon(s).
	X create a rudimentary AI
	_ "tazer caster" -- weapon with two components, fired in sequence from the main barrel.
			when one of the components hits an enemy, it sticks.
			if both components hit enemies, an electrified wire is enabled and starts to destroy the enemies.
			if any other enemies also touch the tazer wire, they are also damaged.
			if the player touches the tazer wire, [I haven't decided what happens]
	_ field to have a complex agent's maximum rotational force magnitude be a variable itself
			calculated as a function of velocity, specified with a single coefficient.
			application: motorcycles, who have trouble turning at high speeds
	_ "gun buddies" -- automated helper agents, mobile or immobile type
			has own AI, and would automatically seek out and destroy enemies until killed.
			can be purchased like ammunition, and can be configured like the player's tank.
	_ "air strikes" -- level-based superweapons, can be picked up. Only one at a time can be equipped/held in reserve
	O laser-based weapons which use a "POWER" meter.
	_ "batteries" for storing POWER.
	_ "generators" which determine power regen rate.
	_ RAIL-based weapons
			instantly travels from source to target, and leave behind a trail that animates (really a series of particles laid out in a line)
			has a fake physics system around it, represents a low-mass slug with a very high velocity
	_ EMP weapons
	_ shields (uses power)
			can be reconfigured at any time to emphasize front, back, or to be evenly spread
	_ stealth device (uses power)
	_ UPGRADES: weapon damage (using ammunition, purchasable), max health, speed (tread type), acceleration (engine), armor (plates, bought in sets, destroyable, visible, can fall off), muzzle velocity of all weapons, turret rotation speed
	X machine gun overheat
	_ ammunition class/type/object for association with turrets. Turrets can store multiple types of ammo, and be pointing to an active one. Each ammunition object would keep track of units remaining.
	_ DEPLOYABLE state for complex agents. Either switch the image entirely or have special animated gizmos that animate with a function call.
	X WIDGETS have been implemented to satisfy requirements for all special particles with animation states
			deploy-gizmos would be some kind of special particle with two states, and an image set for animation frames
			when activated, the gizmo would animate forwards and then freeze.
			when activated again, the gizmo would animate backwards and freeze it its original state.
	_ ammunition loading/reloading animation, and an animation joining the ammo pickup to the ammo display when it gets granted()
	X for TURRETs, allow for an arbitrary number of each type of emitter.
	_ enemy spawner (Carson's idea)
	X put explosion, smoke, spark and damage scar emitters into projectiles.
			when the projectile hits something, emit everything ("dump its load").
	X sound
	X emitters should have a particle_archetype_index range (min/max) so that they can emit many different particles
	_ explosions can also have short-lived "spark" emitters, and sparks have such trails as mentioned above
	X velocity range for projectile emitters -- ties in to weapon accuracy
	X angular velocity for particles
	X angular velocity range for particle emitters
	_ motivator class for animating "treads" and handling debris and trail emitters, attached to complex agents
	X remove dynamic fields (usually physics-related) from CREATE functions (changed them to "Archetype_.." functions)
	X class archetype libraries
	_ put class archetype initialization into XML files
	X create projectile emitter type
	X weapon accuracy values, implemented with angle variance in the projectile emitter
	X attach various emitters to turret class to be called logically on fire()
	X turret recoil
	X emitter's parent can be a particle (or projectile)
			applications: missiles!
	X alpha values for particles, birth & death
	X tread emitter and manager list
	X damage for player and enemies
	X encapsulate turret logic and make a class for it
	_ create xml format for levels
	_ create a level editor
	X implement a physics engine, using Chris Hecker's PDF's as an example
			linear forces, center of mass, rotational physics, etc.
			application: obviously, to make the game world seem more "real"
	X create gibs for enemies
	X make gibs spawn as particles when enemies die
	_ create scars
	X create "shells" to be ejected from the ejector port of turret object
	X create blocks for static environments that can be collided with
	X create example arenas
	X create a few enemies with guns
	O create visible damage which "sticks" to agents
	X separate main components into files
	